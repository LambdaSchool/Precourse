*Closure results when a function has access to variables within the scope of the variable that originally returned it. The first thing to realize is that a function can create ("return") another function. Think of the first function as a factory, and the second function as a robot built by that factory. We tell the first "factory" function how to make the second "robot" function, and also some information and data that the "robot" function will need to complete its tasks.

Now, if we didn't have closure, the situation would be that all the information that the robot needed would need to be saved into the robots memory before it left the factory, or it would have to be information it found out in real time in the world aroudn it. Any information back at the factory that the robot didn't take with it, would be totally lost to the robot. Call this the Non-Closure Bot. If some of the original information Non-Closure Bot was programmed with was changed at the factory for new robots, Non-Closure Bot would not be affected. Likewise, if Non-Closure Bot rewrote some if its data based on its own experiences in the world, the factory would never know about it. Non-Closure Bot would be independent in terms of data and information from the factory that made it.

On the other hand, let's say we have a robot that has a datalink with the factory. Call this Closure Bot. Closure Bot can transmit data to the factory, and the data can transmit data to Closure Bot. So one result is that a lot of the information Closure Bot needs will not be saved locally in Closure Bot's memory, but will be just a link in Closure Bot's memory that connects to the factory, and then the factory provides the data. If the robot needs to perform some complex calculation, it can ask the factory to do it. Plus, Closure Bot can transmit updated information to the factory. So if Closure Bot explores a new territory, it can transmit the information to the factory, which can save the data there. This is interesting, because it allows the Closure Bot to know everything the factory knows, rather than just what data/information was originally uploaded when it was created. It also means that if someone captures the robot, they will only be able to hack into the robots local stored information, but nothing back at the factory, so we don't have to be so worried about the robot being captured and hacked out in the wide world. 

Overall then, closures are a way for functions to have access to the scope that created them, and all the variables contained therein. This adds flexibility, can increase efficiency, and can keep data private. One drawback though, that is not captured by the metaphor, is that there is essentially a new factory each time a robot is created, so having very elaborate "factories" or closures with a lot of information within its scope, can lead to using up lots of memory.